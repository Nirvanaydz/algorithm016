##学习笔记
###1、数组和链表
####1.1、数组array，新建一个数组是内存控制器开了一个连续的内存地址
    数组的实现，参考java中的arraylist的实现，主要关注其add和delete方法
    复杂度分析：
        lookup          O（1）
        add/insert      O（n）
        delete          O（n）        
####1.2、链表的实现机制：
    重要节点：
        head
        tail
        node（data，nextNode）
    节点的不同连接形式可以构成不同种类的链表
    节点双指向：双向链表
    头尾相连：环形链表
    仅指向单一节点：单向链表
    
    优势：链表是如何实现插入和删除的：寻找节点操作其前后的节点进行删除和插入   O（1）
    劣势：链表的查找：性能与数组相比较低，需要重头节点开始遍历查找    O（n）
####1.3、链表的特殊形式：跳表（skip linkedList），在链表的数据是有序的情况下，可以采用空间换时间的思想进行优化查找
    具体思路，将头部节点指向2的思路变成头部节点指向3或者4或者更考后的节点，这样查找起来的话就会快速一些。
    核心思想就是：升维：将一维的结构向上升级，变成二维的结构，这里用到的跳表思想就是将节点的指向进行简化，
        比如原来查找这个有序链表【长度为10】中的8号节点，需要从头部遍历1一直到8号节点，但是现在使用提升维度的方法
        ，将1先指向5，查询到8还在5之后，就直接从5号节点遍历，节约了很长的一部分查询，在链表很短的时候看不出性能差异，
        但是当链表长度以指数级别增长时，就可以使用这种思想，来完成快速的查找，比如有1024个节点，查找1000号时，以前
        遍历需要1000次，但是现在只需要log(1024)次，即10次就完成了查找，很快速。
    但是跳表也有其劣势：首先数据结构有一定要求，有序；其次就是在建立好新的索引之后，插入新的数据的时间复杂度就不是原来
        链表的O（1）了，而是O（n），因为插入也开始使用新的索引进行查询位置信息后再插入，而不是原来的直接插入的方式。
####1.4、核心思想：升维，空间换时间！